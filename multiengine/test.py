# -*- coding: utf-8 -*-

student_answer = {"kran": ["param2", "param1"], "name2": ["param5", "param6"]}
correct_answer = {"kran": {"OR": [["param1", "param2"]]}, "name2": ["param5", "param6"]}
settings = {"sequence": False}


def multicheck(student_answer, correct_answer, settings):
            """
            Сравнивает 2 словаря вида:
                {"name1": ["param1", "param2"], "name2": ["param3", "param4"]}
            с произвольным количеством ключей,

            возвращает долю совпавших значений
            """

            KEYWORDS = ('or', 'and', 'not')

            def max_length(lst):
                length = 0
                for element in lst:
                    if len(element) > length:
                        length = len(element)
                return length

            def _compare_answers_not_sequenced(student_answer, correct_answer, checked=0, correct=0):
                """
                Вычисляет долю выполненных заданий без учета
                последовательности элементов в области
                """
                for key in correct_answer:
                    for value in correct_answer[key]:
                        if value in KEYWORDS:
                            keyword = value
                            correct_values = correct_answer[key][keyword]
                            for correct_value in correct_values:
                                if len(set(correct_value) - set(student_answer[key])) == 0:
                                    with_keyword = True
                                    break
                            if with_keyword:
                                checked += len(student_answer[key])
                                correct += len(student_answer[key])
                            else:
                                checked += len(student_answer[key])

                        elif value in student_answer[key]:
                            checked += 1
                            correct += 1
                        else:
                            checked += 1
                return correct / float(checked)

            def _compare_answers_sequenced(student_answer, correct_answer, checked=0, correct=0):
                """
                Вычисляет долю выполненных заданий с учетом
                последовательности элементов в области
                """
                answer_condition = False

                for key in correct_answer:
                    student_answer_true = []

                    if not isinstance(correct_answer[key], dict):
                        for answer_item in student_answer[key]:
                            if answer_item in correct_answer[key]:
                                student_answer_true.append(answer_item)

                        try:
                            answer_condition = ''.join(student_answer_true) == ''.join(correct_answer[key])
                        except:
                            answer_condition = str(student_answer_true) == str(correct_answer[key])

                        if answer_condition:
                            correct += len(correct_answer[key])
                        checked += len(correct_answer[key])

                    else:
                        for keyword in KEYWORDS:
                            if keyword in correct_answer[key].keys():
                                correct_values = correct_answer[key][keyword]

                                for correct_value in correct_values:
                                    try:
                                        answer_condition = ''.join(student_answer[key]) == ''.join(correct_value)
                                    except:
                                        answer_condition = str(student_answer[key]) == str(correct_value)
                                    if answer_condition:
                                        break

                                checked += max_length(correct_values)

                                if answer_condition:
                                    correct += len(student_answer[key])

                return correct / float(checked)

            if settings['sequence'] is True:
                result = _compare_answers_sequenced(student_answer, correct_answer)
            elif settings['sequence'] is False:
                result = _compare_answers_not_sequenced(student_answer, correct_answer)
            else:
                pass

            return result

print(multicheck(student_answer, correct_answer, settings))